# Building a Data Model
- Introduction to data modeling
- Building an e-commerce data model
- Organizing models in apps
- Coding model classes

## Introduction to Data Modeling
모든 `entity(개체)`는 `id attribute(속성)`을 가지고 있어야 할까?
- Yes, 하지만 `Django`가 자동으로 생성해 주기 때문에 걱정하지 않아도 된다. 
  
<img src="https://cdn-images-1.medium.com/max/800/1*_cp1kwPNoS1sa6_MhwtFDQ.png" />

<img src="https://cdn-images-1.medium.com/max/800/1*HMG2-IXUwBhu0IfWFKIjYg.png" />

## Building an E-commerce Data Model
- One-to-Many Relationships
  
<img src="https://cdn-images-1.medium.com/max/800/1*qxXt-KaJQkDP8GAuFcSPAg.png" />

- 당신의 비즈니스 모델의 요구 사항에 맞춰서 DB를 디자인하자. 이번 프로젝트의 경우 Cart에 담은 물건의 경우 30일 이후에 사라지도록 구성하기 위해, `created_at` `속성 attribute`을 정의했다.
Many-to-Many Relationships

<img src="https://cdn-images-1.medium.com/max/800/1*JXfFN_Zt_H5el65kGN0BZQ.png" />

- 점선은 두 `entity(개체)` 사이의 관계를 나타낸다. 이를 `Association Class`라 표현한다. `CartItem entity`는 `Association Class`라 칭한다. 


<img src="https://cdn-images-1.medium.com/max/800/1*WePizDWsYfnLdPf_VeWZYQ.png" />

- `Association Class` 대신에 다음 사진과 같이 관계형으로 표현할 수 있다.


<img src="https://cdn-images-1.medium.com/max/800/1*M15Fc1weQ3IHAunuAuV96Q.png" />

<img src="https://cdn-images-1.medium.com/max/800/1*yPLqdpNhInONboPHCvAuMg.png" />

### What about the user that owns this card?
- 익명의 사용자 혹은 이름의 사용자에 상관없이 모두 Cart를 이용할 수 있다.
- 다수의 제품을 포함할 경우 아래와 같은 형태의 관계를 띈다.
  
<img src="https://cdn-images-1.medium.com/max/800/1*8BP5NFEdLnYJttnNA9D1nw.png" />

- `Product Entity`와 `Order Entity` 사이에는 `OrderItem Entity`를 이용해 관계가 형성된다.
  
<img src="https://cdn-images-1.medium.com/max/800/1*xo7xkw6OmpoxvCqjjr3d2A.png" />

- `Association Class`대신에 아래와 같이 관계형으로 구성할 수 있다.
  
<img src="https://cdn-images-1.medium.com/max/800/1*hSiy5PEynIRQ6-Lk3xX3Vg.png" />

- 하나의 `Product`과 `Tag`는 `Many-to-Many`의 관계를 가지고 있다.
  
<img src="https://cdn-images-1.medium.com/max/800/1*BKahmygjRyEWEiGO014M1Q.png" />

## Organizing Models in Apps
<img src="https://cdn-images-1.medium.com/max/800/1*k92LaFH6xo-NJ7x8bjyz1Q.png" />

앞서 이야기했듯이 `Django` 프로젝트에는 둘 이상의 앱이 존재하고, 이 앱들끼리 의사소통하는 방식으로 하나의 프로젝트가 구성된다. 각 앱은 특정한 기능을 가지고, 서로서로가 상호 보완적으로 동작한다. 이것이 의미하는 바는, 각 앱은 각자의 `Data Model`을 가지고 있다는 점이다.

- `store`에 관한 기능을 담당하는 앱이 있다고 생각해보자.
  
<img src="https://cdn-images-1.medium.com/max/800/1*cfJm_xxi-Egv42RgxUc9yQ.png" />

- 서비스가 커지면서 너무 많은 기능과 코드가 `store`에 다 작성되면, 코드 관리도 힘들 뿐만 아니라, 확장성도 안 좋아지게 된다. 왜냐하면 하나의 `App`에 너무 많은 `Views`와 `Models`이 존재하기 때문이다.

<img src="https://cdn-images-1.medium.com/max/800/1*hbynErHdpNxFnMhb32mPkQ.png" />
- 위와 같은 현상 혹은 형태의 앱을 `Monolith`라 칭한다.
- 하나의(Mono-) 돌(lith)이라는 의미로, 어느 정도 규모가 있는 구조물이 여러 석재의 조합이 아닌 한 덩어리의 석재로만 이루어져 있을 때 붙을 수 있는 명칭이다. 주로 고대에 만든, 거대한 돌기둥이나 첨탑을 말한다.
- 기념비적 성질을 띄는 돌기둥이나 첨탑은 위치가 정해지면 더 이상 움직일 일이 없기 때문에 그 규모는 공간만 보장된다면 크게 문제가 되지 않는다. 하지만 소프트웨어 같은 경우 끊임없는 변경과 확장을 반복하기 때문에 `monolith` 방식이 적합하지 않는 경우가 많다.
- 너무 많은 기능을 가진 리모컨을 생각하면 쉽게 이해가 될 것이다.
- 필자의 경우 `Do one thing and do it well` 방식을 지키려고 한다. 물론 이게 모든 경우에 정답은 아니다. 항상 그 상황에 맞게 잘 판단해서 방법론을 선택하면 될 것 같다.
<img src="https://cdn-images-1.medium.com/max/800/1*PQm6nF1_osnzMQlN9TsQcQ.png" />

## Do one thing and do it well
<img src="https://cdn-images-1.medium.com/max/800/1*pLCHW2EetgYHW6LAHvaN-g.png" />

- `Orders App` 은 `Carts App`에 의존하고, `Carts App`는 `Customers App`에 의존하고, `Customers App`에 의존하고 `Products App`에 의존한다. 

<img src="https://cdn-images-1.medium.com/max/800/1*OO2wyKJzIQ4GJ7um3Wk6ig.png" />

- 위 경우 아래와 같이 4개의 앱을 모두 다운로드해야한다.

```python
pipenv install products
pipenv install carts
pipenv install customers
pipenv install orders
```

- 하지만 여러 앱이 의존하는 방식을 사용했을 때도 문제가 있다.

<img src="https://cdn-images-1.medium.com/max/800/1*U0GIurhwmDKYPo0kdy9fjw.png" />

- 만약 `Products` 앱에 두 개의 업데이트가 발생했을 때, `Carts`와 `Orders`앱이 `Products` 앱 버전에 맞게 업데이트를 하지 않는 경우 문제가 발생할 수 있다. 

- 위와 같이 네 개의 앱을 구성하고, 그것을 `store`라고 하는 하나의 앱에서 합치는 방식을 사용할 수 있다. 하지만 위 네 개의 앱이 서로 의존하고 있는 것과 달리 큰 의존성이 없는 `tag` 앱이 존재하는 경우 외부에 따로 생성을 하고 따로 의존성 없이 참조해 사용할 수 있다.

<img src="https://cdn-images-1.medium.com/max/800/1*L41mj83VV_dtg2kCcznIWg.png" />

- Zero-Coupling: 위 4개의 앱들과 달리, `Tags` 앱과 같이 의존성이 없는 앱에 어떤 변화가 발생해도 다른 앱에 영향을 미치지 않는 상황을 생각하면 이 용어를 쉽게 이해할 수 있을 것이다.

<img src="https://cdn-images-1.medium.com/max/800/1*-xdJsJJFEL-ujHTX2p0pWg.png" />

- 4개의 앱으로 분류해도 결과적으로 하나의 앱에 합쳐서 동작을 하기 때문에, `monolith` 형태를 띤다. 그렇기 때문에 `monolith` 형태는 피할 수 없기 때문에 두 가지 규칙을 생각하면 프로젝트를 체계적으로 설계할 수 있을 것이다.

1. Minimal Coupling
- 각 앱 간의 의존성을 최소화한다.
2. High Cohesion(Focus)
- 각 앱이 각자의 고유한 기능을 잘 가질 수 있도록 앱을 구성한다.

```python
python manage.py startapp store
python manage.py startapp tags
```

```python
# storefront settings.py

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'playground',
    'store',
    'tags',
]
```

## Creating Models
```python
# store/models.py
from django.db import models

# Create your models here.

# django model fields
# https://docs.djangoproject.com/en/4.0/ref/models/fields/
# check out field options


class Product(models.Model):
    title = models.CharField(max_length=255)  # varchar(255)
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)  # 9999.99
    inventory = models.IntegerField()
    # auto_now vs auto_now_add 차이 알아보기
    last_update = models.DateTimeField(auto_now=True)  # 자동으로 현재시간을 저장함
```
```txt
#Practice

Customer
    first_name
    last_name
    email (unique)
    phone
    birth_date (nullable)
```
```python
# Customer Answer
class Customer(models.Model):
    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
```

왜 `Primary Key`가 없는가 궁금할 수 있다.
`Django`가 자동으로 각 모델에 `ID`를 생성하기 때문에 그 부분은 걱정하지 않아도 된다.

## Choice Fields
- https://docs.djangoproject.com/en/4.0/ref/models/fields/#choices
```python
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold')
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
```

```txt
#Practice

Order
    placed_at (datetime - auto-populated)
    payment_status
        P = Pending
        C = Complete
        F = Failed
```

```python
# Answer

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'

    PAYMENT_STATUS = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS, default=PAYMENT_STATUS_PENDING)
```

## Defining One-to-one Relationships
<img src="https://cdn-images-1.medium.com/max/800/1*Z1XRlQZtw1cmC4a1DsoArw.png" />

- 모든 고객은 반드시 하나의 주소만 가지고 있어야 한다 one-to-one relationship
- Customer Class가 Address Class의 부모이면서, 부모는 반드시 자식보다 먼저 존재해야 하기 때문에 반드시 존재해야 한다.

```python

class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    # primary_key를 설정하지 않으면 Address만의 ID를 Django가 생성하기 때문에 아래와 같이 명시해줘야 한다
    # Customer 클래스에는 자동으로 Address가 추가되기 때문에 별도로 정의할 필요는 없다
    customer = models.OneToOneField(
        Customer, on_delete=models.CASCADE, primary_key=True)
    # on_delete ==> Customer가 삭제되면 어떤 현상이 발생하는가
    # customer = models.OneToOneField(Customer, on_delete=models.CASCADE)부모가 삭제되면 자동으로 삭제되도록 CASCADE
    # customer = models.OneToOneField(Customer, on_delete=models.SET_NULL) SET_NULL로 설정하는 경우 부모가 삭제되지 않고 NULL 값으로 설정됨
    # customer = models.OneToOneField(Customer, on_delete=models.SET_DEFAULT) 기본값
    # customer = models.OneToOneField(Customer, on_delete=models.PROTECT) 부모를 삭제하기 전에 반드시 자식을 먼저 삭제해야 함
```

## Defining One-to-many Relationships
- `Address` 모델과 `Customer` 모델을 `One-to-many` 관계형으로 변경해 보자

```python
class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    # primary_key는 더 이상 필요 없다, 왜냐하면 다수의 값이 허용되기 때문이다
    customer = models.ForeignKey(
        Customer, on_delete=models.CASCADE)
```

```txt
#Practice

Collection - Product ==> 하나의 Collection은 둘 이상의 Product을 가질 수 있다.
Customer - Order ==> 한 명의 Customer는 둘 이상의 Order를 할 수 있다. 
Order - Item ==> 하나의 Order에는 둘 이상의 Item이 존재할 수 있다.
Cart - Item ==> 하나의 Cart에는 둘 이상의 Item이 존재할 수 있다.
```

```python
# Answer
from django.db import models
from django.db.models.deletion import CASCADE

# Create your models here.


class Collection(models.Model):
    title = models.CharField(max_length=255)


class Product(models.Model):
    title = models.CharField(max_length=255)  # varchar(255)
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)  # 9999.99
    inventory = models.IntegerField()
    # 자동으로 현재시간을 저장함, auto_now vs auto_now_add 차이 알아보기
    last_update = models.DateTimeField(auto_now=True)
    # Collection 클래스를 Product 클래스를 생성하기 전에 정의한다 그 이유는 Collection 클래스가 부모 역할을 하기 때문이다
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)


class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold')
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    # One-to-many


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'

    PAYMENT_STATUS = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)


class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)


class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.ForeignKey(
        Customer, on_delete=models.CASCADE)


class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)


class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()
```

## Defining Many-to-many Relationships
- 하나의 `Product`의 둘 이상의 `Promotion`을 가질 수 있다.

```python
class Promotion(models.Model):
    description = models.CharField(max_length=255)
    discount = models.FloatField()
    # products

class Product(models.Model):
    title = models.CharField(max_length=255)  # varchar(255)
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)  # 9999.99
    inventory = models.IntegerField()
    # 자동으로 현재시간을 저장함, auto_now vs auto_now_add 차이 알아보기
    last_update = models.DateTimeField(auto_now=True)
    # Collection 클래스를 Product 클래스를 생성하기 전에 정의한다 그 이유는 Collection 클래스가 부모 역할을 하기 때문이다
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)

    # Many-to-many Relationship
    # 하나의 Product에 다수의 Promotion이 존재할 수 있다.
    # promotions = models.ManyToManyField(Promotion, related_name="products")
    # I'm going to stick to the default convention
    promotions = models.ManyToManyField(Promotion)
```

## Resolving Circular Relationships
<img src="https://cdn-images-1.medium.com/max/800/1*V7UCHC-bn2Fkgq1lGpTIbw.png" />

- 두 종류의 클래스가 동시에 서로에게 의존하고 있는 경우 `Circular Dependency`가 발생한다. 이 현상은 피할 수 있다면 가능한 피해야 한다.
- `Product` 클래스는 `Collection` 클래스에 의존하고, `Collection` 클래스는 `Product` 클래스에 의존한다.
- 하나의 `Product`은 

```python
# related_name을 작성하지 않는 경우 Reverse query name 오류가 발생한다. 이를 해결하기 위해 related_name을 정의해 준다.
# reverse relationship을 신경 쓰지 않는다면 related_name="+"를 정의한다. 
class Collection(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey(
        "Product", on_delete=models.SET_NULL, null=True, related_name="+")

class Product(models.Model):
    title = models.CharField(max_length=255) 
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)  
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
    promotions = models.ManyToManyField(Promotion)
```

- `reverse relationship`에 관하여 자세히 알아보기

## Generic Relationships
- https://leffept.tistory.com/358
- `Tags` 클래스와 같이 다른 요소와 관련 없이 혼자 존재하는 클래스를 `Generic Relationship`이라 칭한다. 이번 파트에서는 이러한 관계에 있는 요소를 구현하는 방식에 대해 알아보자.

<img src="https://cdn-images-1.medium.com/max/800/1*2VA15iHVbirM4MHGBO1wkw.png" />

- 아래 방식은 `Tags` 클래스가 `store.models` 클래스에 의존하는 것이기 때문에 `Generic Relationship`을 가졌다고 칭할 수 없다. 이를 해결해 보자. 
```python
# tags/models.py

from django.db import models
from store.models import Product

class Tag(models.Model):
    label = models.CharField(max_length=255)


class TaggedItem(models.Model):
    # What tag applied to what object
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
    product = models.ForeignKey(Product)
```

```python
# Solution
from django.db import models
# ContentType: 추상 모델이다 (INSTALLED_APPS의 django.contrib.contenttypes에서 전달받은 것이다)
# contentType을 이용해 Generic Relationship을 구현할 수 있다
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class Tag(models.Model):
    label = models.CharField(max_length=255)


class TaggedItem(models.Model):
    # What tag applied to what object
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
    # Type (product, video, article, etc)
    # ID : Identify Any Record or Table
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    # Actual Product을 찾고 싶은 경우 content_object를 사용할 수 있다.
    content_object = GenericForeignKey()
```

```txt
#Practice

App: likes

LikedItem
    - What user likes what object
    - user: ForeignKey to User (django.contrib.auth.models)
```

```python
# Solution
from django.db import models
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class LikedItem(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()
```