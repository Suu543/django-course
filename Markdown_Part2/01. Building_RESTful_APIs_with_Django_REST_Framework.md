# Building RESTful APIs with Django REST Framework
- MODELS
- MIGRATIONS
- QUERYSETS
- VIEWS
- URLCONF

## Setting Up the Project
1. `MySQL Workbench`에서 `storefront2` 데이터베이스를 생성하는 쿼리를 작성한다.
```sql
CREATE DATABASE storefront2
```
2. 새로운 폴더를 하나 생성하고, `Code` ==> `1 - Getting Started` ==> `Start` ==> `storefront2`를 붙여 넣는다. 

3. 아래 커맨드를 `shell`에서 실행한다.
```python
pipenv install
pipenv shell
python manage.py migrate
python manage.py createsuperuser
pipenv shell
python manage.py createsuperuser
```

4. `storefront` ==> `settings.py` 데이터베이스 정보를 작성
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront2',
        'HOST': 'localhost',
        'USER': 'root',
        'PASSWORD': 'password'
    }
```

## Introduction
- Introduction to RESTful APIs
- Installing Django REST Framework
- Creating API Views
- Creating Serializers
- Serializing and Deserializing Models

## What is RESTful APIs?
**REST란** <br />
- REST의 정의
    - “Representational State Transfer” 의 약자
    - 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.
    - 즉, 자원(resource)의 표현(representation) 에 의한 상태 전달
      - 자원(resource)의 표현(representation)
        - 자원: 해당 소프트웨어가 관리하는 모든 것
            -> Ex) 문서, 그림, 데이터, 해당 소프트웨어 자체 등

        - 자원의 표현: 그 자원을 표현하기 위한 이름
            -> Ex) DB의 학생 정보가 자원일 때, ‘students’를 자원의 표현으로 정한다.

      - 상태(정보) 전달
        - 데이터가 요청되어지는 시점에서 자원의 상태(정보)를 전달한다.
        - JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다.


      - 월드 와이드 웹(www)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식

        - REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
        - REST는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.

**REST의 구체적인 개념**
- HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
  - 즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.
  - 웹 사이트의 이미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.

  - CRUD Operation
    - Create : 생성(POST)
    - Read : 조회(GET)
    - Update : 수정(PUT)
    - Delete : 삭제(DELETE)
    - HEAD: header 정보 조회(HEAD)

**REST의 장단점**
장점 <br />
- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
- HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
- HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
- Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
- REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
- 여러가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다.
- 서버와 클라이언트의 역할을 명확하게 분리한다. <br />

단점 <br />
- 표준이 존재하지 않는다.
- 사용할 수 있는 메소드가 4가지 밖에 없다.
- HTTP Method 형태가 제한적이다.
- 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 왠지 더 어렵게 느껴진다.
- 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.
- PUT, DELETE를 사용하지 못하는 점
- pushState를 지원하지 않는 점 <br />

REST가 필요한 이유 <br />
- ‘애플리케이션 분리 및 통합’
- ‘다양한 클라이언트의 등장’
- 최근의 서버 프로그램은 다양한 브라우저와 안드로이폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다. 멀티 플랫폼에 대한 자원을 위해 서비스 자원에 대한 아키텍처가 필요하다. <br />

REST 구성 요소 <br />
- 자원(Resource): URI
  - 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
  - 자원을 구별하는 ID는 ‘/groups/:group_id’와 같은 HTTP URI 다.
  - Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다.

- 행위(Verb): HTTP Method
  - HTTP 프로토콜의 Method를 사용한다.
  - HTTP 프로토콜은 GET, POST, PUT, DELETE 와 같은 메서드를 제공한다.

- 표현(Representation of Resource)
  - Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.
  - REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 Representation으로 나타내어 질 수 있다.
  - JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다. <br />

REST 특징 <br />
- Server-Client(서버-클라이언트 구조)
    - 자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client가 된다.
      - REST Server: API를 제공하고 비즈니스 로직 처리 및 저장을 책임진다.
      - Client: 사용자 인증이나 context(세션, 로그인 정보) 등을 직접 관리하고 책임진다.
    - 서로 간 의존성이 줄어든다. <br />

Stateless(무상태) <br />
  - HTTP 프로토콜은 Stateless Protocol이므로 REST 역시 무상태성을 갖는다.
  - Client의 context를 Server에 저장하지 않는다.
    - 즉, 세션과 쿠키와 같은 context 정보를 신경쓰지 않아도 되므로 구현이 단순해진다.
  - Server는 각각의 요청을 완전히 별개의 것으로 인식하고 처리한다.
    - 각 API 서버는 Client의 요청만을 단순 처리한다.
    - 즉, 이전 요청이 다음 요청의 처리에 연관되어서는 안된다.
    - 물론 이전 요청이 DB를 수정하여 DB에 의해 바뀌는 것은 허용한다.
    - Server의 처리 방식에 일관성을 부여하고 부담이 줄어들며, 서비스의 자유도가 높아진다. <br />

Cacheable(캐시 처리 가능) <br />
- 웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다.
  - 즉, HTTP가 가진 가장 강력한 특징 중 하나인 캐싱 기능을 적용할 수 있다.
  - HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.
- 대량의 요청을 효율적으로 처리하기 위해 캐시가 요구된다.
- 캐시 사용을 통해 응답시간이 빨라지고 REST Server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용률을 향상시킬 수 있다. <br />

Layered System(계층화) <br />
- Client는 REST API Server만 호출한다.
- REST Server는 다중 계층으로 구성될 수 있다.
  - API Server는 순수 비즈니스 로직을 수행하고 그 앞단에 보안, 로드밸런싱, 암호화, 사용자 인증 등을 추가하여 구조상의 유연성을 줄 수 있다.
  - 또한 로드밸런싱, 공유 캐시 등을 통해 확장성과 보안성을 향상시킬 수 있다.
- PROXY, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다. <br />

Code-On-Demand(optional) <br />
- Server로부터 스크립트를 받아서 Client에서 실행한다.
- 반드시 충족할 필요는 없다. <br />

Uniform Interface(인터페이스 일관성) <br />
- URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다.
- HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
    - 특정 언어나 기술에 종속되지 않는다.

REST API의 개념 <br />

REST API란
- API(Application Programming Interface)란
  - 데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능 하도록 하는 것

REST API의 정의
- REST 기반으로 서비스 API를 구현한 것
- 최근 OpenAPI(누구나 사용할 수 있도록 공개된 API: 구글 맵, 공공 데이터 등), 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처) 등을 제공하는 업체 대부분은 REST API를 제공한다. <br />

REST API의 특징 <br />
- 사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
- REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.
- 즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.

REST API 설계 기본 규칙 <br />
참고 리소스 원형 <br />
- 도큐먼트 : 객체 인스턴스나 데이터베이스 레코드와 유사한 개념
- 컬렉션 : 서버에서 관리하는 디렉터리라는 리소스
- 스토어 : 클라이언트에서 관리하는 리소스 저장소

1. URI는 정보의 자원을 표현해야 한다.
- resource는 동사보다는 명사를, 대문자보다는 소문자를 사용한다.
- resource의 도큐먼트 이름으로는 단수 명사를 사용해야 한다.
- resource의 컬렉션 이름으로는 복수 명사를 사용해야 한다.
- resource의 스토어 이름으로는 복수 명사를 사용해야 한다.
  - Ex) GET /Member/1 -> GET /members/1

2. 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등)로 표현한다.
- URI에 HTTP Method가 들어가면 안된다.
  - Ex) GET /members/delete/1 -> DELETE /members/1

- URI에 행위에 대한 동사 표현이 들어가면 안된다.(즉, CRUD 기능을 나타내는 것은 URI에 사용하지 않는다.)
  - Ex) GET /members/show/1 -> GET /members/1
  - Ex) GET /members/insert/2 -> POST /members/2

- 경로 부분 중 변하는 부분은 유일한 값으로 대체한다.(즉, :id는 하나의 특정 resource를 나타내는 고유값이다.)
  - Ex) student를 생성하는 route: POST /students
  - Ex) id=12인 student를 삭제하는 route: DELETE /students/12 <br />

REST API 설계 규칙 <br />
1. 슬래시 구분자(/ )는 계층 관계를 나타내는데 사용한다.
- Ex) http://restapi.example.com/houses/apartments

2. URI 마지막 문자로 슬래시(/ )를 포함하지 않는다.
- URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 한다.
- REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다.
- Ex) http://restapi.example.com/houses/apartments/ (X)

3. 하이픈(- )은 URI 가독성을 높이는데 사용
- 불가피하게 긴 URI경로를 사용하게 된다면 하이픈을 사용해 가독성을 높인다.

4. 밑줄(_ )은 URI에 사용하지 않는다.
- 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 하므로 가독성을 위해 밑줄은 사용하지 않는다.

5. URI 경로에는 소문자가 적합하다.
- URI 경로에 대문자 사용은 피하도록 한다.
- RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문

6. 파일확장자는 URI에 포함하지 않는다.
- REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다.
- Accept header를 사용한다.
  - Ex) http://restapi.example.com/members/soccer/345/photo.jpg (X)
  - Ex) GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg (O)

7. 리소스 간에는 연관 관계가 있는 경우
- /리소스명/리소스 ID/관계가 있는 다른 리소스명
  - Ex) GET : /users/{userid}/devices (일반적으로 소유 ‘has’의 관계를 표현할 때)

8. REST API 설계 예시 <br />
<img src="https://gmlwjd9405.github.io/images/network/restapi-example.png" />

RESTful의 목적 <br />
- 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있는 것이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것이 주 동기이니, 성능이 중요한 상황에서는 굳이 RESTful한 API를 구현할 필요는 없다. <br />

RESTful 하지 못한 경우
- Ex1) CRUD 기능을 모두 POST로만 처리하는 API
- Ex2) route에 resource, id 외의 정보가 들어가는 경우 /students/updateName

References
- https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html

## Resources
`RESTful API 장점`
- Fast
- Scalable
- Reliable
- Easy to understand
- Easy to change

`RESTful API URL`
- Product
- Collection
- Cart

```python
http://cozybuy.com/products
http://cozybuy.com/products/1
http:/cozybuy.com/products/1/reviews
http://cozybuy.com/products/1/reviews/1
```

`Resourece Representations`
- HTML
- XML
- JSON (JavaScript Object Notation)

```json
{
    "name": "yongsu",
    "age": 26,
    "is_online": True,
    "employer": {},
    "interests": []
}
```

## HTTP Methods
- GET
- POST
- PUT
- PATCH
- DELETE

`Creating a Product`
```python
POST /products
{
    "title": "...",
    "price": 10
}
```
`Updating a Product`
```python
PATCH /products/1
PUT /products/1

{
    "title": "...",
    "price": 10
}
```
`Deleting a Product`
```python
DELETE /products/1
```

## Installing Django REST Framework
```python
pipenv install djangorestframework
```

```python
# settings/INSTALLED_APPS
INSTALLED_APPS = [
    # ...
    'rest_framework'
    # ...
]
```

## Creating API Views
아래와 같은 URL을 만드는 방법에 대해 알아보자.
```python
127.0.0.1:8000/store/products
```

1. `Djagno` 방식
```python
# store/views.py
from django.shortcuts import render
from django.http import HttpResponse

# Create your views here.
def product_list(request):
    return HttpResponse('ok')
```
```python
# store/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("products/", views.product_list)
]

```
```python
# storefront/urls.py
"""storefront URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
import debug_toolbar

admin.site.site_header = 'Storefront Admin'
admin.site.index_title = 'Admin'

urlpatterns = [
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('__debug__/', include(debug_toolbar.urls)),
]
```

2. `REST Framework` 방식 <br />
<img src="https://cdn-images-1.medium.com/max/800/1*-_HjJXCf7vok-MKwiXsE_Q.png" />

- Before
<img src="https://cdn-images-1.medium.com/max/800/1*a17jZtY4EpDh8a2EfG7evw.png" />

- After
<img src="https://cdn-images-1.medium.com/max/800/1*NCivffPCHCGgseCNuRTA9w.png" />

```python
from django.shortcuts import render
from django.http import HttpResponse
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def product_list(request):
    return Response("ok")
```

- `product_detail` 메서드 추가

```python
# store/views.py/product_detail
@api_view()
def product_detail(request, id):
    return Response(id)
```

- `id`에 숫자가 아닌 문자를 넣으면 오류가 발생한다.
```python
# store/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("products/", views.product_list),
    path("products/<int:id>", views.product_detail)
]
```

## Creating Serializers
<img src="https://cdn-images-1.medium.com/max/800/1*WTdKp_VNhKgXux3pfPpYPg.png" />
- `Product Object`를 데이터베이스로부터 받아와서, `Python or Django`가 이해할 수 있는 형태로 바꿔보자. 
- `dictionary object`를 인자로 받아 `json` 형태로 리턴해준다.

<img src="https://cdn-images-1.medium.com/max/800/1*JldB-EWRny5ZZ94x1M2TQA.png" />
- 이렇게 데이터베이스에서 데이터를 받아와, `dictionary` 등 `Python or Django`에 활용할 수 있는 형태로 바꾸는 과정을 `Serializer`라 칭한다.

```python
# store/serializers.py
from rest_framework import serializers

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
```

## Serializing Objects

```python
# Part-1
from django.shortcuts import render
from django.http import HttpResponse
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import Product
from .serializers import ProductSerializer 

@api_view()
def product_list(request):
    return Response("ok")

@api_view()
def product_detail(request, id):
    product = Product.objects.get(pk=id)
    print(product)
    serializer = ProductSerializer(product)
    return Response(serializer.data)
```
<img src="https://cdn-images-1.medium.com/max/800/1*Kwfo5X2g_X1VKSU6SeUXvA.png" />
- 위 사진을 보면 `unit_price`가 여전히 문자열임을 알 수 있다.
- 이 문제를 해결해 보자.

```python
# storefront/settings.py
REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False
}
```
- 아래 사진과 같이 잘 해결된 것을 확인할 수 있다.
<img src="https://cdn-images-1.medium.com/max/800/1*9U3JZCSS3dEyyWLLYmvQpQ.png" />

- 만약 존재하지 않는 `Product`을 요청하면 어떻게 될까?
- 아래와 같이 오류가 발생한다.
- 이 오류는 `404(Not Found)`로 간주되는데, `try ~ except` 문을 활용해 예외 처리를 해보자.
<img src="https://cdn-images-1.medium.com/max/800/1*xXg5EdZVlZj_Ia-FlTDhbQ.png" />

```python
@api_view()
def product_detail(request, id):
    try:
        product = Product.objects.get(pk=id)
        print(product)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    except Product.DoesNotExist:
        return Response(status=404)
```
- 위와 같이 `try ~ except`를 활용해 코드를 수정하면 아래와 같이 출력된다.
<img src="https://cdn-images-1.medium.com/max/800/1*eQ9diJrhcC-yQV_hlShboA.png" />

- `404`는 `magic number`이기 때문에, 이를 보다 직관적이게 `rest_framework`에서 제공해 주는 도구를 활용해 개선해 보자.
  
```python
@api_view()
def product_detail(request, id):
    try:
        product = Product.objects.get(pk=id)
        print(product) 
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    except Product.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)
```
- 일일이 위 코드를 작성하는 과정은 번거롭다.
- `rest_framework`는 이 과정을 줄여주는 기능을 제공한다.

```python
from django.shortcuts import render, get_object_or_404

@api_view()
def product_detail(request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
```
- `product_list`의 `view`도 정의해 보자.

```python
@api_view()
def product_list(request):
    queryset = Product.objects.all()
    serializer = ProductSerializer(queryset, many=True)
    return Response(serializer.data)
```
- `ProductSerializer`에 하나의 데이터가 아닌 둘 이상`(queryset)`을 인자로 전달하는 경우, `many=True` 옵션을 붙여줘야 한다. 그렇게 되면 개별의 요소로 인식하고, 화면에 데이터를 보여준다.

## Creating Custom Serializer Fields
<img src="https://cdn-images-1.medium.com/max/800/1*zUVZK-4vcpgnKZFlwKDrhA.png" />
- `Data Model`은 `Implementation of Detail of Our Application`이다. 이것은 나중에 변경될 수 있다.
- 그렇기 때문에 이런 내용은 리모컨을 사용하는 것처럼, 기능만 겉으로 노출하고, 내부 내용은 `Private` 상태로 둔다.
- `Product` 모델에 존재하지 않는 필드를 추가해 보자.

```python
# store/serializers.py
from rest_framework import serializers
from .models import Product

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    
    def calculate_tax(self, product: Product):
        return product.unit_price * 1.1
```
- 위 코드를 실행했을 때, 아래와 같은 오류가 발생한다. 이 오류를 해결해 보자.
<img src="https://cdn-images-1.medium.com/max/800/1*e7E-lrg6PYiXgpq_8-M8gw.png" />

```python
from decimal import Decimal
from rest_framework import serializers
from .models import Product

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```
- 정상적으로 결과가 잘 출력되는 것을 확인할 수 있다.
<img src="https://cdn-images-1.medium.com/max/800/1*Z1LeOLJTCGFtfBhj4z4L5A.png" />

- 만약 `unit_price`이름을 `price`로 변경하고 싶은 경우, `source` 옵션을 추가해서 변경해 줘야 한다.
```python
from decimal import Decimal
from rest_framework import serializers
from .models import Product

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```
<img src="https://cdn-images-1.medium.com/max/800/1*TMtDf_NqaTxqzj_zLfHyVw.png" />

## Serializing Relationships

```python
from decimal import Decimal
from rest_framework import serializers
from .models import Product, Collection

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.PrimaryKeyRelatedField(
        queryset=Collection.objects.all()
    )
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```
- 아래와 같은 오류가 출력되면, 서버를 켰다가 다시 키면 해결된다.
```python
AssertionError: Relational field must provide a `queryset` argument, override `get_queryset`, or set read_only=`True`.
```
<img src="https://cdn-images-1.medium.com/max/800/1*ykq53uhy1_2bzm8X0NfwHw.png" />

- `PrimaryKeyRelatedField` 대신에 `StringRelatedField`를 사용할 수 있다.
- StringRelatedField의 경우 __str__ 메서드를 참조한다.
- 모든 Product에 하나하나 요청을 다 보내기 때문에 되게 긴 시간이 걸린다.

```python
from decimal import Decimal
from rest_framework import serializers
from .models import Product, Collection

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    collection = serializers.StringRelatedField()
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```

- 위 문제를 해결해보자.
- `Product` 필드를 가져오기 전, `Collection` 필드를 먼저 가져와 캐싱을 하는 방식으로 문제를 해결할 수 있다.

```python
# store/views.py
@api_view()
def product_list(request):
    queryset = Product.objects.select_related("collection").all()
    serializer = ProductSerializer(queryset, many=True)
    return Response(serializer.data)
```

<img src="https://cdn-images-1.medium.com/max/800/1*SvdOWu6Vbe9-dG57e3bf0g.png" />

- 선택은 각자의 선호도에 달려있기 때문에, 어떤 것을 사용하던 큰 상관은 없다.
- 필자는 두 방식 대신에, `CollectionSerializer`를 따로 하나 생성해 추가하는 방식을 사용한다.
```python
from decimal import Decimal
from rest_framework import serializers
from .models import Product, Collection

class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = CollectionSerializer()
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```

<img src="https://cdn-images-1.medium.com/max/800/1*vHKN0kT3bpVPBUh5vILoEw.png" />

- 위 사진에 보면, `collection`의 값에 `object` 형태로 들어가 있는 것을 확인할 수 있다. 이를 링크 형태로 변경해 보자.
1. `urls` module에 `collection_detail`에 해당하는 링크를 추가
2. `collection_detail` 메소드 생성
3. `collection_detail`에 관한 코드를 `serializer`에 추가

```python
# store/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("products/", views.product_list),
    path("products/<int:id>", views.product_detail),
    path("collections/<int:id>/", views.collection_detail, name="collection-detail")
]
```

```python
# store/views.py
@api_view()
def collection_detail(request, id):
    return Response("ok")
```

```python
# store/serializers.py
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name='collection-detail'
    )
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```

- 코드를 실행하면 다음과 같은 오류가 출력된다. 똑같이 서버를 켰다가 다시 키면 정상적으로 동작한다.
```python
# AssertionError: The `view_name` argument is required.
```

- 이후 화면에 아래와 같은 오류가 출력된다.
<img src="https://cdn-images-1.medium.com/max/800/1*Kh8-wJKYJmU_C83t_0hz4Q.png" />
- `requires the request in the serializer context` ==> `serializer`에도 `request`를 전달해 주자.

```python
# store/views.py
@api_view()
def product_list(request):
    queryset = Product.objects.select_related("collection").all()
    serializer = ProductSerializer(queryset, many=True, context={'request': request})
    return Response(serializer.data)
```

- 이후 화면에 아래와 같은 오류가 출력된다.
<img src="https://cdn-images-1.medium.com/max/800/1*qHYZdEWTXSiyPLRPVSeYjg.png" />

- `Django REST Framework`는 특정한 컨벤션을 원하기 때문에, `url`을 정의할 때, `id` 대신에 `pk`등의 컨벤션을 따라서 `params`을 정의해야 한다.
- `Django REST Framework`는 `pk`를 읽고, 이를 활용해 `Collection`을 검토하고 원하는 데이터를 찾아낸다.

```python
# store/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("products/", views.product_list),
    path("products/<int:id>", views.product_detail),
    path("collections/<int:pk>/", views.collection_detail, name="collection-detail")
]
```

```python
# store/views.py
@api_view()
def collection_detail(request, pk):
    return Response("ok")
```

- 이제 결과가 정상적으로 출력되는 것을 확인할 수 있다.
<img src="https://cdn-images-1.medium.com/max/800/1*VjWVAR_jnw0WQHJ5mph-bw.png" />

### Serializing Relationships
- `Serializing Relationships`에는 총 4가지 종류의 방식이 있다.
1. Primary Key
2. String
3. Nested Object
4. Hyperlink

## Model Serializers
- 이전에 작성한 `Serializer`를 확인해 보면, `id, title` 등이 같은 패턴으로 반복되는 것을 확인할 수 있다.
- `model serializer`를 이용해 이 과정을 단순화해보자.
```python
from decimal import Decimal
from rest_framework import serializers
from .models import Product, Collection

class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name='collection-detail'
    )
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```

- `Model Serializer`를 적용한 경우
```python
# store/serializers.py
from decimal import Decimal
from rest_framework import serializers
from .models import Product, Collection

class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'collection']
```
<img src="https://cdn-images-1.medium.com/max/800/1*mFA4Xt2hFc74vN9UWgcBIw.png" />

- `ModelSerializer`는 기본값으로 `PrimaryKeyRelatedField`이 설정된다.
- 만약 이것을 변경하고 싶다면 (Override) 할 수 있다.

```python
# store/serializers.py
from decimal import Decimal
from rest_framework import serializers
from .models import Product, Collection

class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'collection']

    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name='collection-detail'
    )
```

<img src="https://cdn-images-1.medium.com/max/800/1*PI8gdEWswrZCbLnVZo-6Tg.png" />
- `unit_price`를 `price`로 변경하고 싶은 경우

```python
# store/serializers.py
from decimal import Decimal
from rest_framework import serializers
from .models import Product, Collection

class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'price', 'collection']

    price = serializers.DecimalField(max_digits=6, decimal_places=2, source="unit_price")
    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name='collection-detail'
    )
```
<img src="https://cdn-images-1.medium.com/max/800/1*ZiVkZlGG-ywuQmpbkejShw.png" />
- `price_with_tax`를 추가하고 싶은 경우

```python
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'price_with_tax', 'collection']

    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name='collection-detail'
    )

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1) 
```
<img src="https://cdn-images-1.medium.com/max/800/1*mVTS9REg24abHIe7JTFJFg.png" />
- 모든 필드를 보고 싶은 경우 아래와 같이 코드를 작성하면 된다. 하지만, 이 방식은 민감한 정보를 외부에 노출할 수 있는 가능성이 있기 때문에 사용하는 것을 추천하지 않는다.

```python
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = '__all__'
```

- `CollectionSerializer`에도 `Model Serializer`를 반영해 보자.

```python
# store/serializers.py
from decimal import Decimal
from rest_framework import serializers
from .models import Product, Collection

class CollectionSerializer(serializers.Serializer):
    class Meta:
        model = Collection
        fields = ['id', 'title']

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'price_with_tax', 'collection']

    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = serializers.HyperlinkedRelatedField(
        queryset=Collection.objects.all(),
        view_name='collection-detail'
    )
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```

## Deserializing Objects
- 아래 사진과 같이, 사용자가 `POST` 방식으로 하나의 `Product`을 생성하는 경우, 이전과는 반대로 `Deserializing` 방식을 통해 데이터를 추출해, `DB`에 저장해야 한다.
<img src="https://cdn-images-1.medium.com/max/800/1*urDmXdVGK1ogv4VMnlvsig.png" />
- `GET`은 기본값이다.

```python
# store/views.py
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == "GET":
        # Serializing
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    elif request.method == "POST":
        # Deserializing
        serializer = ProductSerializer(data=request.data)
        # serializer.validated_data
        return Response("ok")
```

- 제일 아랫부분을 보면 다음 사진과 같이 출력된다.
<img src="https://cdn-images-1.medium.com/max/800/1*Y0PdEAKQ996MK_VXqMwCUg.png" />
- `empty object`를 `content`에 작성하고 `POST` 버튼을 눌러보자.
- 아래와 같이 결과가 출력된다.
<img src="https://cdn-images-1.medium.com/max/800/1*5uKaq9Lq8IgSwAWZnSrkvA.png" />

## Data Validation
```python
# store/views.py
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == "GET":
        # Serializing
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    elif request.method == "POST":
        # Deserializing
        serializer = ProductSerializer(data=request.data)
        serializer.validated_data
        return Response("ok")
```
- `validated_data` 부분의 주석을 취소하고, `empty object`를 `content`에 작성하고 `POST` 버튼을 누르면 다음과 같은 오류가 출력된다.
<img src="https://cdn-images-1.medium.com/max/800/1*_fyRjaPhz9pzLgS4FxHWhQ.png" />

```python
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == "GET":
        # Serializing
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    elif request.method == "POST":
        # Deserializing
        serializer = ProductSerializer(data=request.data)
        if serializer.is_valid():
            serializer.validated_data
            return Response("ok")
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)       
```
- 위와 같이 코드를 수정하고 실행하면, `empty object`를 `content`에 작성하고 `POST` 버튼을 누르면 다음과 같은 오류가 출력된다.
<img src="https://cdn-images-1.medium.com/max/800/1*5njxTj-MHec1A3kWQrApvA.png" />

- 조금 더 깔끔히 코드를 수정해 보자.
```python
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == "GET":
        # Serializing
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    elif request.method == "POST":
        # Deserializing
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.validated_data
        return Response("ok")
```
- 위와 같이 코드를 수정하고 실행하면, `empty object`를 `content`에 작성하고 `POST` 버튼을 누르면 다음과 같은 오류가 출력된다.
<img src="https://cdn-images-1.medium.com/max/800/1*5njxTj-MHec1A3kWQrApvA.png" />

- `validate_data`가 어떤 형태인지 `print`를 이용해 알아보자.
```python
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == "GET":
        # Serializing
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    elif request.method == "POST":
        # Deserializing
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        print(serializer.validated_data)
        return Response("ok")
```
- 이번에는 유요한 방식으로 `content`를 작성하고 `POST` 버튼을 눌러보자
```python
{
  "title": "a",
  "unit_price": 1,
  "collection": 1
}
```
<img src="https://cdn-images-1.medium.com/max/800/1*ytSEi6GZkIvxwsEtPbo4OQ.png"/>
- `print(serializer.validated_data)` 결과
```python
OrderedDict([('title', 'a'), ('unit_price', Decimal('1.00')), ('collection', <Collection: collection1>)])
```

- 현재 구현한 `validation` 로직으로는, 회원가입을 한다고 가정했을 때, 비밀번호와, 비밀번호 재확인에 입력한 값이 같은지 확인이 불가능하다.
- 만약 이런 기능을 구현하고 싶은 경우, `serializer`에 가서, 기존의 필드를 `override` 해줘야 한다. 
- 예를 들면, 아래와 같다.
```python
# store/serializers.py
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'price_with_tax', 'collection']

    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    # collection = serializers.HyperlinkedRelatedField(
    #     queryset=Collection.objects.all(),
    #     view_name='collection-detail'
    # )
    
    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
    
    # 이 부분
    def validate(self, data):
        # data = Dictionary
        if data['password'] != data['confirm_password']:
            return serializers.ValidationError("Passwords do not match...")
        return data
```

## Saving Objects
- `save` 메서드에는 내부적으로 `validated_data object`에서 데이터를 추출하고, 이것을 생성하거나 업데이트하는 로직을 가지고 있다. 그렇기 때문에 `serializer.validated_data`는 작성하지 않아도 괜찮다. 

```python
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == "GET":
        # Serializing
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    elif request.method == "POST":
        # Deserializing
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response("ok")
```
- 유요한 방식으로 `content`를 작성하고 `POST` 버튼을 눌러보자, 아래와 같은 오류가 발생한다.
```python
{
  "title": "a",
  "unit_price": 1,
  "collection": 1
}
```
<img src="https://cdn-images-1.medium.com/max/800/1*EhO0KnoYkAn8GL2ix6D9Wg.png" />
- 이 오류는 `inventory`는 `Product`의 `required field` 중 하나인데 명시하지 않았기 때문에 발생하는 오류다.
- 아래와 같이 `ProductSerializer`를 수정하자.

```python
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'description', 'slug', 'inventory', 'unit_price', 'price_with_tax', 'collection']

    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
```

- 이후 아래와 같이 `content`를 작성하고 `POST` 버튼을 눌러보자, 아래와 같은 오류가 발생한다.
```python
{
  "title": "a",
  "slug": "a",
  "unit_price": 1,
  "collection": 1,
  "inventory": 1
}
```
<img src="https://cdn-images-1.medium.com/max/800/1*ef5c6U0w-Pl5JB4niigSMA.png" />

- `DB`에 데이터를 생성하는, 내부적으로 정의된 `create`란 메서드를 `override`를 통해, 내가 원하는 방식으로 데이터가 저장될 수 있게 만들어보자.
```python
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'description', 'slug', 'inventory', 'unit_price', 'price_with_tax', 'collection']

    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
    
    def create(self, validated_data):
        # **validated_data = Unpacked
        product = Product(**validated_data)
        product.other = 1
        product.save()
        return product
    
    def update(self, instance, validated_data):
        instance.unit_price = validated_data.get("unit_price")
        instance.save()
        return instance
```

- 데이터를 업데이트하는 방법에 대해 알아보자.
- `http://127.0.0.1:8000/store/products/1
- `PUT` or `PATCH` 어떤 것을 사용하고 안 하는 것은 개인 선호에 달려있다.
- `product_list` 메서드의 `return` 값도 생성한 데이터와, `HTTP Status` 코드를 리턴하도록 정의했다.
```python
# store/views.py
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == "GET":
        # Serializing
        queryset = Product.objects.select_related("collection").all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    elif request.method == "POST":
        # Deserializing
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)
      
        
@api_view(['GET', 'PUT', 'PATCH'])
def product_detail(request, id):
        product = get_object_or_404(Product, pk=id)
    
        if request.method == 'GET':
            serializer = ProductSerializer(product)
            return Response(serializer.data)
        elif request.method == "PUT":
            # product instance를 전달해 줘야 한다.
            serializer = ProductSerializer(product, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
```
- 이후 아래와 같이 `content`를 작성하고 `POST` 버튼을 눌러보자
```python
{
  "title": "a",
  "slug": "a",
  "unit_price": 1,
  "collection": 1,
  "inventory": 1
}
```
<img src="https://cdn-images-1.medium.com/max/800/1*I6tW9MtZc1dWetVLlyiOwA.png" />

- `http://127.0.0.1:8000/store/product/2/` 링크로 이동해, 아래와 같이 데이터를 작성하고 업데이트해보자.
- `id`와 `price_with_tax` 필드는 제거하고, `title`을 `hello_world`로 변경해보자.
```python
{
    "title": "hello world",
    "description": null,
    "slug": "a",
    "inventory": 1,
    "unit_price": 1.0,
    "collection": 1
}
```
- 아래 사진과 같이 정상적으로 업데이트된 것을 확인할 수 있다.
<img src="https://cdn-images-1.medium.com/max/800/1*O648Wi_WvahoEEola31OyQ.png" />
<img src="https://cdn-images-1.medium.com/max/800/1*0JUFtduqKWR6UhePi5wCbA.png" />

```python
# Collection POST Testcase
{
  "title": "test"
}
```

## Deleting Objects
- `product_detail` 메서드에 `DELETE`를 추가하면, 아래와 같이 `DELETE` 버튼이 생성되는 것을 확인할 수 있다.
```python
# store/views.py/product_detail
@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
        product = get_object_or_404(Product, pk=id)
    
        if request.method == 'GET':
            serializer = ProductSerializer(product)
            return Response(serializer.data)
        elif request.method == "PUT":
            # product instance를 전달해 줘야 한다.
            serializer = ProductSerializer(product, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
```
<img src="https://cdn-images-1.medium.com/max/800/1*WXulkYZ4eg6IQ6QSYtQang.png" />

- `request.method == "DELETE"`인 경우, 처리하는 로직을 추가해 보자.
```python
@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
        product = get_object_or_404(Product, pk=id)
    
        if request.method == 'GET':
            serializer = ProductSerializer(product)
            return Response(serializer.data)
        elif request.method == "PUT":
            # product instance를 전달해 줘야 한다.
            serializer = ProductSerializer(product, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
        elif request.method == "DELETE":
            product.delete()
            return Response(status=status.HTTP_204_NO_CONTENT)
```
- 아래와 같이 정상적으로 `product`이 삭제되는 것을 확인할 수 있다.
<img src="https://cdn-images-1.medium.com/max/800/1*2m3Wqj0IyJQMCJK6qSIGcw.png" />
- 만약 `orderItem`과 같이, 다른 테이블에 연관되어 있는 경우`(associated relationship)` 아래와 같이 코드 작성이 가능하다.

```python
@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
        product = get_object_or_404(Product, pk=id)
    
        if request.method == 'GET':
            serializer = ProductSerializer(product)
            return Response(serializer.data)
        elif request.method == "PUT":
            # product instance를 전달해 줘야 한다.
            serializer = ProductSerializer(product, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
        elif request.method == "DELETE":
            if product.orderitem_set.count() > 0:
                return Response({ 'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
            
            product.delete()
            return Response(status=status.HTTP_204_NO_CONTENT)
```
- 필자는 `orderitem_set`과 같은 값이 직관적이지 않다고 생각한다. 그렇기 때문에 이를 직관적이게 변경하기 위해서 `OrderItem` 모델에 `related_name`을 추가했다.
```python
# store/models.py
class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT, related_name="orderitems")
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)
```

- `orderitems_set` 대신에 `orderitems`로 접근해 로직을 작성할 수 있다.
```python
@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
        product = get_object_or_404(Product, pk=id)
    
        if request.method == 'GET':
            serializer = ProductSerializer(product)
            return Response(serializer.data)
        elif request.method == "PUT":
            # product instance를 전달해 줘야 한다.
            serializer = ProductSerializer(product, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
        elif request.method == "DELETE":
            if product.orderitems.count() > 0:
                return Response({ 'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
            
            product.delete()
            return Response(status=status.HTTP_204_NO_CONTENT)
```

자세한 `HTTP Status`에 대해 알고 싶은 경우 아래 사이트를 참고할 수 있다.
- https://httpstatus.com/

## Exercise: Building the Collections APIs
<img src="https://cdn-images-1.medium.com/max/800/1*LC_bDFGpXc7U5veZXdDPtQ.png" />
<img src="https://cdn-images-1.medium.com/max/800/1*1IEUjrL-VlcoaUhsxMFVFg.png" />

```python
# store/views.py
@api_view(["GET", "POST"])
def collection_list(request):
    if request.method == 'GET':
        queryset = Collection.objects.annotate(products_count=Count('products')).all()
        serializer = CollectionSerializer(queryset, many=True)
        return Response(serializer.data)
    
    elif request.method == 'POST':
        serializer = CollectionSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)
        
@api_view(['GET', 'PUT', 'DELETE'])
def collection_detail(request, pk):
    collection = get_object_or_404(
        Collection.objects.annotate(
            products_count=Count('products')), pk=pk)
    if request.method == 'GET':
        serializer = CollectionSerializer(collection)
        return Response(serializer.data)
    elif request.method == 'PUT':
        serializer = CollectionSerializer(collection, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
    elif request.method == 'DELETE':
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
```

```python
# store/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
    path('collections/', views.collection_list),
    path('collections/<int:pk>/', views.collection_detail, name='collection-detail'),
]
```

```python
# store/serializers.py
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ['id', 'title', 'products_count']

    products_count = serializers.IntegerField(required=False)
```

```python
# store/admin.py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    autocomplete_fields = ['featured_product']
    list_display = ['title', 'products_count']
    search_fields = ['title']

    @admin.display(ordering='products_count')
    def products_count(self, collection):
        url = (
            reverse('admin:store_product_changelist')
            + '?'
            + urlencode({
                'collection__id': str(collection.id)
            }))
        return format_html('<a href="{}">{} Products</a>', url, collection.products_count)

    # 이 부분 중요
    def get_queryset(self, request):
        return super().get_queryset(request).annotate(
            products_count=Count('product')
        )
```

```python
# store/models.py
class Product(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField()
    description = models.TextField(null=True, blank=True)
    unit_price = models.DecimalField(
        max_digits=6,
        decimal_places=2,
        validators=[MinValueValidator(1)])
    inventory = models.IntegerField(validators=[MinValueValidator(0)])
    last_update = models.DateTimeField(auto_now=True)
    # 이 부분 중요
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT, related_name="products")
    promotions = models.ManyToManyField(Promotion, blank=True)

    def __str__(self) -> str:
        return self.title

    class Meta:
        ordering = ['title']
```